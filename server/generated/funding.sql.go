// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: funding.sql

package queries

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addFundingOpportunity = `-- name: AddFundingOpportunity :one
insert into funding_opportunities(title, description, target_amount, link, deadline_date)
values($1, $2, $3, $4, $5)
returning id, title, description, target_amount, link, created_on, deadline_date
`

type AddFundingOpportunityParams struct {
	Title        string
	Description  string
	TargetAmount pgtype.Numeric
	Link         pgtype.Text
	DeadlineDate pgtype.Date
}

func (q *Queries) AddFundingOpportunity(ctx context.Context, arg AddFundingOpportunityParams) (FundingOpportunity, error) {
	row := q.db.QueryRow(ctx, addFundingOpportunity,
		arg.Title,
		arg.Description,
		arg.TargetAmount,
		arg.Link,
		arg.DeadlineDate,
	)
	var i FundingOpportunity
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.TargetAmount,
		&i.Link,
		&i.CreatedOn,
		&i.DeadlineDate,
	)
	return i, err
}

const getAllFundingOpportunities = `-- name: GetAllFundingOpportunities :many
select id, title, description, target_amount, link, created_on, deadline_date
from funding_opportunities
`

func (q *Queries) GetAllFundingOpportunities(ctx context.Context) ([]FundingOpportunity, error) {
	rows, err := q.db.Query(ctx, getAllFundingOpportunities)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FundingOpportunity
	for rows.Next() {
		var i FundingOpportunity
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.TargetAmount,
			&i.Link,
			&i.CreatedOn,
			&i.DeadlineDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFundingOpportunitiesByNameSortedByHighestAmountWithinDeadlineAndAmountRanges = `-- name: GetFundingOpportunitiesByNameSortedByHighestAmountWithinDeadlineAndAmountRanges :many
SELECT id, title, description, target_amount, link, created_on, deadline_date
FROM funding_opportunities
WHERE funding_opportunities.title ILIKE $1 AND deadline_date BETWEEN $2 AND $3 AND target_amount BETWEEN $4 AND $5
ORDER BY target_amount DESC
`

type GetFundingOpportunitiesByNameSortedByHighestAmountWithinDeadlineAndAmountRangesParams struct {
	Title          string
	DeadlineDate   pgtype.Date
	DeadlineDate_2 pgtype.Date
	TargetAmount   pgtype.Numeric
	TargetAmount_2 pgtype.Numeric
}

func (q *Queries) GetFundingOpportunitiesByNameSortedByHighestAmountWithinDeadlineAndAmountRanges(ctx context.Context, arg GetFundingOpportunitiesByNameSortedByHighestAmountWithinDeadlineAndAmountRangesParams) ([]FundingOpportunity, error) {
	rows, err := q.db.Query(ctx, getFundingOpportunitiesByNameSortedByHighestAmountWithinDeadlineAndAmountRanges,
		arg.Title,
		arg.DeadlineDate,
		arg.DeadlineDate_2,
		arg.TargetAmount,
		arg.TargetAmount_2,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FundingOpportunity
	for rows.Next() {
		var i FundingOpportunity
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.TargetAmount,
			&i.Link,
			&i.CreatedOn,
			&i.DeadlineDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFundingOpportunitiesByNameSortedByLowestAmountWithinDeadlineAndAmountRanges = `-- name: GetFundingOpportunitiesByNameSortedByLowestAmountWithinDeadlineAndAmountRanges :many
SELECT id, title, description, target_amount, link, created_on, deadline_date
FROM funding_opportunities
WHERE funding_opportunities.title ILIKE $1 AND deadline_date BETWEEN $2 AND $3 AND target_amount BETWEEN $4 AND $5
ORDER BY target_amount ASC
`

type GetFundingOpportunitiesByNameSortedByLowestAmountWithinDeadlineAndAmountRangesParams struct {
	Title          string
	DeadlineDate   pgtype.Date
	DeadlineDate_2 pgtype.Date
	TargetAmount   pgtype.Numeric
	TargetAmount_2 pgtype.Numeric
}

func (q *Queries) GetFundingOpportunitiesByNameSortedByLowestAmountWithinDeadlineAndAmountRanges(ctx context.Context, arg GetFundingOpportunitiesByNameSortedByLowestAmountWithinDeadlineAndAmountRangesParams) ([]FundingOpportunity, error) {
	rows, err := q.db.Query(ctx, getFundingOpportunitiesByNameSortedByLowestAmountWithinDeadlineAndAmountRanges,
		arg.Title,
		arg.DeadlineDate,
		arg.DeadlineDate_2,
		arg.TargetAmount,
		arg.TargetAmount_2,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FundingOpportunity
	for rows.Next() {
		var i FundingOpportunity
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.TargetAmount,
			&i.Link,
			&i.CreatedOn,
			&i.DeadlineDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFundingOpportunitiesSortedByHighestAmountWithinDeadlineAndAmountRanges = `-- name: GetFundingOpportunitiesSortedByHighestAmountWithinDeadlineAndAmountRanges :many
SELECT id, title, description, target_amount, link, created_on, deadline_date
FROM funding_opportunities
WHERE deadline_date BETWEEN $1 AND $2 AND target_amount BETWEEN $3 AND $4
ORDER BY target_amount DESC
`

type GetFundingOpportunitiesSortedByHighestAmountWithinDeadlineAndAmountRangesParams struct {
	DeadlineDate   pgtype.Date
	DeadlineDate_2 pgtype.Date
	TargetAmount   pgtype.Numeric
	TargetAmount_2 pgtype.Numeric
}

func (q *Queries) GetFundingOpportunitiesSortedByHighestAmountWithinDeadlineAndAmountRanges(ctx context.Context, arg GetFundingOpportunitiesSortedByHighestAmountWithinDeadlineAndAmountRangesParams) ([]FundingOpportunity, error) {
	rows, err := q.db.Query(ctx, getFundingOpportunitiesSortedByHighestAmountWithinDeadlineAndAmountRanges,
		arg.DeadlineDate,
		arg.DeadlineDate_2,
		arg.TargetAmount,
		arg.TargetAmount_2,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FundingOpportunity
	for rows.Next() {
		var i FundingOpportunity
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.TargetAmount,
			&i.Link,
			&i.CreatedOn,
			&i.DeadlineDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFundingOpportunitiesSortedByLowestAmountWithinDeadlineAndAmountRanges = `-- name: GetFundingOpportunitiesSortedByLowestAmountWithinDeadlineAndAmountRanges :many
SELECT id, title, description, target_amount, link, created_on, deadline_date
FROM funding_opportunities
WHERE deadline_date BETWEEN $1 AND $2 AND target_amount BETWEEN $3 AND $4
ORDER BY target_amount ASC
`

type GetFundingOpportunitiesSortedByLowestAmountWithinDeadlineAndAmountRangesParams struct {
	DeadlineDate   pgtype.Date
	DeadlineDate_2 pgtype.Date
	TargetAmount   pgtype.Numeric
	TargetAmount_2 pgtype.Numeric
}

func (q *Queries) GetFundingOpportunitiesSortedByLowestAmountWithinDeadlineAndAmountRanges(ctx context.Context, arg GetFundingOpportunitiesSortedByLowestAmountWithinDeadlineAndAmountRangesParams) ([]FundingOpportunity, error) {
	rows, err := q.db.Query(ctx, getFundingOpportunitiesSortedByLowestAmountWithinDeadlineAndAmountRanges,
		arg.DeadlineDate,
		arg.DeadlineDate_2,
		arg.TargetAmount,
		arg.TargetAmount_2,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FundingOpportunity
	for rows.Next() {
		var i FundingOpportunity
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.TargetAmount,
			&i.Link,
			&i.CreatedOn,
			&i.DeadlineDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
